// forEach - перебирает элементы массива и выполняет с ними callback функцию

// map - перебирает элементы массива и выполняет с ними callback функцию
// то, что callback функция возвращает попадает в новый массив

// filter - перебирает элементы массива и выполняет с ними callback функцию
// те элементы, в которыми функция вернула true остаются в итоговом массиве,
// а иные отбрасываются

// find - возвращает первое значение в массиве, которое при вызове callback
// возвращает true

// reduce - получает callback функцию, которая получает результат предидущего
// вызова callback и следующий элемент из массива

// const arr = [12, 4, 32, 45, 6, 43, 23];
// const arr = ["велосипед", "самокат", "ролики", "лыжи"];

// вывести эти числа в консоль (по одному)

// arr.forEach((el) => console.log(el));

// вывести в консоль только четные числа

// const newarr = arr
//   .filter((el) => el % 2 === 0)
//   .forEach((el) => console.log(el));

// console.log(newarr);

// const newarr = arr
//   .filter((el) => el % 2 === 0)
//   .map((el) => {
//     el = Math.pow(el, 2);
//     return el;
//   });
// console.log(newarr);

// написать программу, которая формирует из массива со строками массив с их длинами

// const newarr = arr.map((el) => el.length);
// console.log(newarr);
// -----------------------------------------------------------------------------------------------------------
// написать программу, которая формирует из массива со строками массив с объектами
// каждый объект состоит из свойства word (само слово) и length (длинна слова)

// const newarr = arr.map((el) => ({
//   word: el,
//   length: el.length,
// }));
// console.log(newarr);

const arr = [
  { id: 1, word: "велосипед", length: 9 },

  { id: 2, word: "самокат", length: 7 },

  {
    id: 3,
    word: "ролики",
    length: 6,
  },

  {
    id: 4,
    word: "лыжи",
    length: 4,
  },
];
// необходимо сформировать массив из названий (word

const newarr = arr.map((el) => el.word);

const newarr1 = arr.map(({ id, word }) => ({ id, word }));

console.log(newarr, newarr1);
